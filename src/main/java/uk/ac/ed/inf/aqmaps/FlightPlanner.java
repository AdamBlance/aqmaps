package uk.ac.ed.inf.aqmaps;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.lang.Math;

import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.geojson.Point;
import com.mapbox.geojson.Polygon;

import static uk.ac.ed.inf.aqmaps.PointUtils.distanceBetween;
import static uk.ac.ed.inf.aqmaps.PointUtils.mod360;
import static uk.ac.ed.inf.aqmaps.PointUtils.nearestBearing;
import static uk.ac.ed.inf.aqmaps.PointUtils.oppositeBearing;

public class FlightPlanner {

	// recording the path should be the responsibility of the drone
	
	// This should take in the start point, sensor points and try to devise a good path
	
	private NoFlyZoneChecker noFlyZoneChecker;
	private HashMap<Point, SensorData> sensors;	
	
	private List<Point> flightPlan;
	
	public FlightPlanner(HashMap<Point, SensorData> sensors, NoFlyZoneChecker noFlyZoneChecker) {
		this.noFlyZoneChecker = noFlyZoneChecker;
		this.sensors = sensors;
	}
	
	
	// Returns a high-level flight path generated by the greedy algorithm
	// TODO: Tidy the find minimum bit and use streams instead
	public List<Point> greedyPath(Point start) {		
		var dronePath = new ArrayList<Point>();
		dronePath.add(start);
		
		var curr = start;
		double minDistance;
		Point minSensor;
		
		// For every single sensor
		for (int i = 0; i < 33; i++) {
		
			minDistance = Double.MAX_VALUE;
			minSensor = Point.fromLngLat(0, 0);
			
			for (Point sensor : sensors.keySet()) {
				var dist = distanceBetween(curr, sensor);
				if (dist < minDistance) {
					if (!dronePath.contains(sensor)) {
						minDistance = dist;
						minSensor = sensor;
					}
				}
			}
			if (minSensor.latitude() != 0)	{
				curr = minSensor;
				dronePath.add(curr);  // Path acts as the visited thing
			} else {
				System.out.println("Stuck!");
				break;
			}
		}
		dronePath.add(start);
		return dronePath;
	}
	
	// TODO: Implement this to optimise the path if you have time
	// Note that the start pos appears twice in the path, might break 2-opt
	public List<Point> twoOpt(List<Point> path){
		return new ArrayList<Point>();
	}
	
}
