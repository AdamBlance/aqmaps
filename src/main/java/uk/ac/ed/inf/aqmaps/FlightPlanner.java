package uk.ac.ed.inf.aqmaps;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.lang.Math;

import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.geojson.Point;
import com.mapbox.geojson.Polygon;

import static uk.ac.ed.inf.aqmaps.PointUtils.distanceBetween;

public class FlightPlanner {

	// recording the path should be the responsibility of the drone
	
	// This should take in the start point, sensor points and try to devise a good path
	
	private NoFlyZoneChecker noFlyZoneChecker;
	private List<Sensor> sensors;

	
	public FlightPlanner(List<Sensor> sensors, NoFlyZoneChecker noFlyZoneChecker) {
		this.noFlyZoneChecker = noFlyZoneChecker;
		this.sensors = sensors;
	}
	
	
	// Returns a high-level flight path generated by the greedy algorithm
	// TODO: Tidy the find minimum bit and use streams instead
	public List<Sensor> greedyPath(Point start) {		
		var dronePath = new ArrayList<Sensor>();
		var unvisited = new ArrayList<Sensor>(sensors);
		var currentPoint = start;
		
		for (int i = 0; i < sensors.size(); i++) {
			var closest = closestSensor(currentPoint, unvisited);
			currentPoint = closest.getPoint();
			dronePath.add(closest);
			unvisited.remove(closest);
		}		
		return dronePath;
	}
	
	public List<Waypoint> twoOptPath(Point start) {
		List<Waypoint> path = new ArrayList<>();
		
		var startWaypoint = new Waypoint(start);
		path.add(startWaypoint);
		path.addAll(greedyPath(start));
		path.add(startWaypoint);
		
		// Go through every possible subpath in the path and reverse it if its shorter
		
		boolean improved = true;		
		while (improved) {
			improved = false;
			outerloop:
			for (int i = 1; i < path.size() - 1; i++) {
				for (int j = i+1; j < path.size() - 1; j++) {
					double diff = pathDifference(path, i, j);
					if (diff < 0) {
						path = modifiedPath(path, i, j);
						improved = true;					
						break outerloop;
					}
				}
			}
		}
		return path.subList(1, path.size() - 1);
	}
	
	// inclusive
	private double pathDifference(List<Waypoint> path, int start, int end) {
		
		if (start <= 0 || end >= path.size() - 1) {
			throw new RuntimeException("Can't change the start or end point");
		}
		
		var beforeStartP = path.get(start - 1).getPoint();
		var startP = path.get(start).getPoint();
		
		var endP = path.get(end).getPoint();
		var afterEndP = path.get(end + 1).getPoint();
		
		double penalty = 0.0000;
		
		
		double lengthBefore = distanceBetween(beforeStartP, startP) + distanceBetween(endP, afterEndP);
		double lengthAfter = distanceBetween(beforeStartP, endP) + distanceBetween(startP, afterEndP);
		
		lengthBefore += (noFlyZoneChecker.isMoveLegal(beforeStartP, startP) ? 0 : penalty) + (noFlyZoneChecker.isMoveLegal(endP, afterEndP) ? 0 : penalty);
		lengthAfter+= (noFlyZoneChecker.isMoveLegal(beforeStartP, endP) ? 0 : penalty) + (noFlyZoneChecker.isMoveLegal(startP, afterEndP) ? 0 : penalty);
		
		return lengthAfter - lengthBefore;
	}
	
	// no penalty - 
	
//	for (int p = 0; p < newPath.size() - 1; p++) {
//	if (noFlyZoneChecker.isMoveLegal(newPath.get(p).getPoint(), newPath.get(p+1).getPoint())) {
//		dist += 0.0006;
//	}
//}
	
	private List<Waypoint> modifiedPath(List<Waypoint> path, int s, int e) {
		var output = new ArrayList<>(path);
		for (int i = s; i <= e; i++) {
			output.set(i, path.get(e-(i-s)));
		}
		return output;
	}
	
	private double pathLength(List<Waypoint> route) {
		double length = 0;
		for (int i = 0; i < route.size() - 1; i++) {
			length += distanceBetween(route.get(i).getPoint(), route.get(i+1).getPoint());
		}
		return length;
	}
	
	private static Sensor closestSensor(Point point, List<Sensor> sensors) {
		return sensors.stream()
				.min((Sensor a, Sensor b) -> Double.compare(distanceBetween(point, a.getPoint()), distanceBetween(point, b.getPoint())))
				.get();
		
		
//		var closestSensor = unvisited.stream()
//		.map(s -> new AbstractMap.SimpleEntry<Sensor, Double>(s, distanceBetween(currentPoint, s.getPoint())))
//		.min(Comparator.comparing(AbstractMap.SimpleEntry::getValue))
//		.get().getKey();
		
	}
		
//		var curr = start;
//		double minDistance;
//		Point minSensor;
//		
//		
//		
//		// For every single sensor
//		for (int i = 0; i < 33; i++) {
//		
//			minDistance = Double.MAX_VALUE;
//			minSensor = Point.fromLngLat(0, 0);
//			
//			for (var sensor : sensors) {
//				var dist = distanceBetween(curr, sensor.getPoint());
//				if (dist < minDistance) {
//					if (!dronePath.contains(sensor)) {
//						minDistance = dist;
//						minSensor = sensor;
//					}
//				}
//			}
//			if (minSensor.latitude() != 0)	{
//				curr = minSensor;
//				dronePath.add(curr);  // Path acts as the visited thing
//			} else {
//				System.out.println("Stuck!");
//				break;
//			}
//		}
//		dronePath.add(start);
//		return dronePath;
	
}
